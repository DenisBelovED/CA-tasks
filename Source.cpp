//задача о проверке графа на двудольность

#include <fstream>
#include <vector>
#include <queue>
#include <string> 
#include <sstream>

using namespace std;

// метот преобразует T в string
template <typename T> 
string toString(T val) 
{
	ostringstream oss;
	oss << val;
	return oss.str();
}

// метод провер€ет граф на двудольность, использу€ раскраску графа
// формально: если существуют две вершины одинакового цвета, соединЄнные ребром, то граф не двудольный 
string checkGraph(vector<vector<int>> graph, queue<int> queue, vector<int> color, int n)
{
	// коротко -------
	// начинаем обход в ширину, зна€, что в очередь внесена кака€-то вершина, и помечена в какой-то цвет
	// пока очередь не пуста, выт€гиваем из неЄ вершину, смотрим смежные с ней вершины по матрице смежности
	// закидываем непосещЄнные смежные вершины в очередь
	// попутно делаетс€ проверка св€занности двух вершин одинакового цвета
	// ---------------
	while (!queue.empty())  
	{
		int column_index = queue.front(); // берЄм элемент из очереди (не удал€€)
		queue.pop(); // удал€ем его
		// проход по смежным вершинам
		for (int i = 0; i < n; i++)  
			// проверим, что мы не стоим сами на себе, и что ребро существует
			if ((column_index != i) && ((bool)graph[column_index][i]))
				// если цвет вершины, на которую мы смотрим, равен -1, то закинем еЄ в очередь,
				// и изменим еЄ цвет, на противоположный цвету текущей вершины
				if (color[i] == -1)
				{
					queue.push(i);
					if (color[column_index] == 0)
						color[i] = 1;
					if (color[column_index] == 1)
						color[i] = 0;
				}
				else
					// иначе граф не двудольный
					if (color[column_index] == color[i])
						return "N";

	}

	// если в граф не св€зен, то он не двудолен
	for (auto i : color)
		if (i == -1)
			return "N";

	// формируем строку-ответ ------------
	string s2 = "", s3 = "";
	for (int i = 0; i < n; i++)
		if (color[i] == 0)
			s2 += toString(i + 1);
		else
			s3 += toString(i + 1);
	// -----------------------------------

	return "Y" + s2 + "0" + s3; // возвращаем ответ
}

int main()
{
	ifstream fin("in.txt"); // открытие файла дл€ чтени€ данных

	int n = 0, c; // n - кол-во вершин в графе, c - число, характеризующее наличие ребра (1 или 0)
	
	fin >> n; // читаем n

	vector<vector<int>> graph; // здесь храним граф, как матрицу смежности
	vector<int> color(n, -1); // массив флагов, характеризующих вершины: -1 -- не посещена 
							  //                                          0 -- принадлежит первой доле
							  //                                          1 -- принадлежит второй доле
	queue<int> queue; // очередь дл€ нужд алгоритма обхода в ширину

	// заполнениие матрицы смежности graph---
	for (int i = 0; i < n; i++)
	{
		graph.push_back(vector<int>());
		for (int j = 0; j < n; j++)
		{
			fin >> c;
			graph[i].push_back(c);
		}
	}
	// --------------------------------------
	fin.close(); // закрытие фаила дл€ чтени€ данных
	
	ofstream fout("out.txt"); // открытие файла дл€ записи ответа
	
	// проверка, состоит ли граф из одной вершины ---
	if (n == 1) 
	{
		fout << "N";
		return 0;
	}
	// ----------------------------------------------

	queue.push(0); // предварительно выбираем вершину дл€ начала обхода
	color[0] = 0; // метим еЄ как посещЄнную, и принадлежащую к первой доле графа
	fout << checkGraph(graph, queue, color, n); // выводим ответ в файл
	
	fout.close(); // закрытие файла дл€ записи ответа
	
	return 0;
}